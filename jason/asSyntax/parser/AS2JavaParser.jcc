// Copyright (C) 2003  Rafael H. Bordini, Jomi F. Hubner, et al.
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// 
// To contact the authors:
// http://www.dur.ac.uk/r.bordini
// http://www.inf.furb.br/~jomi
//----------------------------------------------------------------------------


options {
   //LOOKAHEAD=3;
   FORCE_LA_CHECK=true;
   STATIC=false;
}

PARSER_BEGIN(as2j)

  package jason.asSyntax.parser;

  import java.util.*;
  import java.io.*;
  import jason.asSyntax.*;
  import jason.asSemantics.*;

  public class as2j {

    private String name;
    private File source = null;

    private PrintStream out = System.out;

    /* Auxiliary Functions */

    void setName(String n) {
    	name = n;
    }

    void setSource(File f) {
        source = f;
    }
  }

PARSER_END(as2j)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN : {
// Predefined
  <TK_TRUE: "true">
| <TK_FALSE: "false">
| <TK_NOT:  "not">
| <TK_NEG:  "~">

// special chars
| <TK_LABEL_AT: "@">

// Numbers
//|   <NUMBER: ("-")? ["0"-"9"] (["0"-"9"])*
//          | (("-")? ["0"-"9"])* "." (["0"-"9"])+ (<EXPONENT>)?
//          | (("-")? ["0"-"9"])+ <EXPONENT> >
|   <NUMBER: ["0"-"9"] (["0"-"9"])*
          | (["0"-"9"])* "." (["0"-"9"])+ (<EXPONENT>)?
          | (["0"-"9"])+ <EXPONENT> >
|  <EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>

// Strings
|  <STRING: "\"" ( ~["\"","\\","\n","\r"]
                 | "\\" ( ["n","t","b","r","f","\\","\'","\""]
                        | ["0"-"7"] (["0"-"7"])?
                        | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">

// Identifiers
|  <ATOM: (<LC_LETTER> | "." <CHAR>) (<CHAR> | "." <CHAR>)*>
|  <VAR:  <UP_LETTER> (<CHAR>)*>
|  <CHAR: (<LETTER> | <DIGIT> | "_")>
|  <LETTER: ( <LC_LETTER> | <UP_LETTER> )>
|  <LC_LETTER: ["a"-"z"]>
|  <UP_LETTER: ["A"-"Z"]>
|  <DIGIT: ["0"-"9"]>
}

/* AgentSpeak Grammar */

void ag(Agent a) : { List bbl = new LinkedList(); PlanLibrary pp;  }
{
  bs(bbl)
  pp = ps()
  <EOF>
              { if (a != null) {
                    a.addPS(pp); 
  
                    // add beliefs (when the plans are loaded, so the events are relevant
                    Iterator i = bbl.iterator();
                    while (i.hasNext()) {
                       Literal l = (Literal)i.next();
                       Circumstance c = null;
                       try {
                          c = a.getTS().getC();
                       } catch (Exception e) {}
                       a.addBel(l, BeliefBase.TSelf, c, Intention.EmptyInt);
                    }
                 }
               }
}

/* Beliefs */
void bs(List bbl) : { Literal F; }
{
  ( F=l() "."       {  if(!F.isGround()) {
				            throw new ParseException("Error: Initial belief must be ground!\n       Cannot use "+F+" as initial belief.");
                       }
                       bbl.add(F);
                    } 
  )*
}

/* Plans */
PlanLibrary ps() : { PlanLibrary pp = new PlanLibrary(); Plan pl;  }
{
  ( pl = p()       { pp.add(pl); } 
  )*
                   { return pp; }
}

/* Plan */
Plan p() :         { Trigger T; ArrayList C; ArrayList H; Pred L = null; }
{
    [ <TK_LABEL_AT> L=at() ] 
    T=te() 
    ":" C=ct() 
    "<-" H=bd() "." 
                   { return new Plan(L,T,C,H);  }
}

/* Trigger */
Trigger te() : { 
               		boolean teType;
			    	byte    teGoal = Trigger.TEBel;
				 	Literal F; 
               }
{
  ( "+"        { teType = Trigger.TEAdd; }
  | "-"        { teType = Trigger.TEDel; }
  )
  
  [ ( "!"      { teGoal = Trigger.TEAchvG; }
    | "?"      { teGoal = Trigger.TETestG; }
    )
  ]
  
  F=l()        { return new Trigger(teType,teGoal,F); }
}

/* Literal */
Literal l() :  { Pred F; Token k; boolean type = Literal.LPos; }
{
  ( ( [ <TK_NEG>              { type = Literal.LNeg; }
      ]
      F=at()                  { return new Literal(type,F); }
    )
  | k=<TK_TRUE>               { return Literal.LTrue;}  // used when dl/body is true
  | k=<TK_FALSE>              { return Literal.LFalse; } 
  )
}


/* Plan context */
ArrayList ct() :    { DefaultLiteral P; ArrayList C = new ArrayList(); List CT;}
{
     P = dl()       { if (!P.getLiteral().equals(Literal.LTrue)) {
                        C.add(P); 
                      }
                    }
     [ "&" CT=ct()  { C.addAll(CT); } 
     ]
                    { return C; }
}


DefaultLiteral dl() : { boolean isPos = DefaultLiteral.LDefPos; 
                        Term rel = null;
                      }
{
  [ <TK_NOT>          { isPos = DefaultLiteral.LDefNeg; }
  ]

  rel = relationalExpression() 
                      { if (rel.isVar()) {
                          return new DefaultLiteral(isPos, (VarTerm)rel);
                        } else if (rel.isLiteral()) {
                          return new DefaultLiteral(isPos, (Literal)rel);
                        } else {
                          return new DefaultLiteral(isPos, new Literal(rel)); 
                        }
                      }
                     
}


/* Plan body */
ArrayList bd() : { BodyLiteral F; 
                   ArrayList BD = new ArrayList(); 
                   List BD2;}
{
  F=f()          { if (! F.getLiteral().equals(Literal.LTrue)) {
                      BD.add(F); 
                   } 
                 }
                 
  [ ";" BD2=bd() { BD.addAll(BD2); } ]
                 { return BD; }
}


BodyLiteral f() :     { Literal A; Token k;
                        byte formType = BodyLiteral.HAction;
                        Term rel;
                      }
{
 
 ( LOOKAHEAD(4)
   // goals and belief updates
   (  "!"             { formType = BodyLiteral.HAchieve; }
    | "?"             { formType = BodyLiteral.HTest; }
    | "+"             { formType = BodyLiteral.HAddBel; }
    | "-"             { formType = BodyLiteral.HDelBel; }
   )
   ( A=l()            { return new BodyLiteral(formType,A); }
   | k = <VAR>        { return new BodyLiteral(formType,new VarTerm(k.image)); } // used in communication "+C"
   )
 |
  // actions or expressions
  rel = relationalExpression() 
                      { if (rel.isVar()) {
                          return new BodyLiteral(formType, (VarTerm)rel); // the action is the Var content
                        } else if (rel.isLiteral()) {
                          return new BodyLiteral(formType, (Literal)rel);
                        } else {
                          return new BodyLiteral(formType, new Literal(rel)); 
                        }
                      }
 )
}


/* Annotated Atomic Formulae */
Pred at() : { Token K; Pred p = new Pred(); Term t; }
{
  K=<ATOM> { p.setFunctor(K.image); } 
  [
      "(" lt(p) ")"
  ]
  [ 
      "[" la(p) "]"
  ] 
  { return p; }
}


/* List of terms as parameters */
Term lt(Term u) :   { Term v; }
{
  v=t()             { u.addTerm(v); } 
  ( "," v=t()       { u.addTerm(v); }
  )* 
                    { return u; }
}

/* List of terms as annotations */
Pred la(Pred p) :  { Term v; }
{
  v=t()            { p.addAnnot(v); }
  ( "," v=t()      { p.addAnnot(v); }
  )*               { return p; }
}

Term t() :         { Token K; Term u; NumberTerm nb;}
{
  ( u=l()          { return u; }
  | u=list()       { return u; } 
  | nb=arithmeticExpression() { return (Term)nb; }
  | K=<STRING>     { return new StringTerm(K.image.replaceAll("\"", "\\\"")); } 
  )
}


ListTerm list() : { ListTerm lt = new ListTerm(); ListTerm last; Token K; Term f; }
{
  "["
  [
  f=t()               { last = lt.add(f); }
  ( "," f=t()         { last = last.add(f); }
  )*
  [ "|"  ( K=<VAR>    { last.setTail(new VarTerm(K.image)); }
         | f=list()   { last = last.concat((ListTerm)f);	   }
         )           
  ]
  ]
  "]"                 { return lt; } 
}


/* relational expression 
   used in context and body
   
     <VAR>      [ <OPREL> <EXP> ]  --> this method returns the VarTerm
   | <LITERAL>  [ <OPREL> <EXP> ]  --> returns the Literal
   | <EXP> <OPREL> <EXP>           --> returns a Term like .gt(<Term>,<Term>)
*/
Term relationalExpression() :              { Token k;
                                             Term op1 = null;
                                             Term op2 = null;
                                             NumberTerm nb; 
                                             String operator = "";
                                             boolean change = false;
                                             Term rel = null;
                                           }
{
    (   nb = arithmeticExpression()        { op1 = (Term)nb; }
      | op1 = l()
      | k = <STRING>                       { op1 = new StringTerm(k.image); }
    )
                     
    [
       ( "<"                               { operator = ".gt"; change = true; } 
       | "<="                              { operator = ".gte"; change = true; } 
       | ">"                               { operator = ".gt"; } 
       | ">="                              { operator = ".gte"; } 
       | "=="                              { operator = ".equals"; } 
       | "\\=="                            { operator = ".notequals"; } 
       | "="                               { operator = ".unifies"; } 
       )

       (   nb = arithmeticExpression()     { op2 = (Term)nb; }
         | op2 = l()
         | k = <STRING>                    { op2 = new StringTerm(k.image); }
       )

                                           { rel = new Term(operator);
                                             if (!change) {
                                                 rel.addTerm(op1); 
                                                 rel.addTerm(op2); 
                                 			  } else {
                                                 rel.addTerm(op2); 
                                                 rel.addTerm(op1); 
                                             }
                                           }
    ]
                                           { if (rel == null && !op1.isVar() && !op1.isLiteral()) {
                                                throw new ParseException("RelExp: second operand expected");
                                             }
                                             if (rel != null) {
                                                return rel; 
                                             } else { // op1 is a Var or Literal
                                                return op1;
                                             }
                                           }
}


/* arithmetic expression */
NumberTerm arithmeticExpression() : { NumberTerm t1, t2; int op;}
{
   t1 = trm()        { op = -1; }
[  ( "+"             { op = ExprTerm.EOplus;} 
   | "-"             { op = ExprTerm.EOminus;}
   )
   t2 = arithmeticExpression()
                     { return new ExprTerm(t1,op,t2); }
]                    { return t1; }
}

NumberTerm trm() :  { NumberTerm t1, t2; int op;}
{
   t1 = factor()    { op = -1; }
[  ( "*"            { op = ExprTerm.EOtimes; } 
   | "/"            { op = ExprTerm.EOdiv; }
   )
   t2 = trm()       { return new ExprTerm(t1,op,t2); }
]                   { return t1; }
}

NumberTerm factor():{ NumberTerm t1, t2; int op;}
{
   t1 = simple()    { op = -1; }
[  ( "%"            { op = ExprTerm.EOmod; } 
   | "**"           { op = ExprTerm.EOpow; }
   )
   t2 = factor()    { return new ExprTerm(t1,op,t2); }
]                   { return t1; }
}


NumberTerm simple():{ Token K; NumberTerm t;}
{
 ( K = <NUMBER>     { return new NumberTermImpl(K.image); }
 | K = <VAR>        { return new VarTerm(K.image); }
 | "-" t = simple() { return new ExprTerm(ExprTerm.EOminus, t); }
 | "(" t = arithmeticExpression() ")"  { return t; }
 )
}

