// Copyright (C) 2003  Rafael H. Bordini, Jomi F. Hubner, et al.
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// 
// To contact the authors:
// http://www.dur.ac.uk/r.bordini
// http://www.inf.furb.br/~jomi
//
//----------------------------------------------------------------------------


options {
   FORCE_LA_CHECK=true;
   STATIC=false;
}

PARSER_BEGIN(as2j)

  package jason.asSyntax.parser;

  import java.util.*;
  import java.io.*;
  import jason.asSyntax.*;
  import jason.asSyntax.directives.*;
  import jason.asSemantics.*;
  import jason.bb.*;
  import jason.*;
  import jason.asSyntax.ArithExpr.ArithmeticOp;
  import jason.asSyntax.LogExpr.LogicalOp;
  import jason.asSyntax.RelExpr.RelationalOp;
  import jason.asSyntax.BodyLiteral.BodyType;

  public class as2j {

    private String name;
    private File source = null;

    private PrintStream out = System.out;

    /* Auxiliary Functions */

    void setName(String n) {
    	name = n;
    }

    void setSource(File f) {
        source = f;
    }
  }

PARSER_END(as2j)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN : {
// Predefined
  <TK_TRUE: "true">
| <TK_FALSE: "false">
| <TK_NOT:  "not">
| <TK_NEG:  "~">
| <TK_INTDIV: "div">
| <TK_INTMOD: "mod">

// special chars
| <TK_LABEL_AT: "@">

// Numbers
|   <NUMBER: ["0"-"9"] (["0"-"9"])*
          | (["0"-"9"])* "." (["0"-"9"])+ (<EXPONENT>)?
          | (["0"-"9"])+ <EXPONENT> >
|  <EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>

// Strings
|  <STRING: "\"" ( ~["\"","\\","\n","\r"]
                 | "\\" ( ["n","t","b","r","f","\\","\'","\""]
                        | ["0"-"7"] (["0"-"7"])?
                        | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">

// Identifiers
|  <ATOM      : (<LC_LETTER> | "." <CHAR>) (<CHAR> | "." <CHAR>)*>
|  <VAR       :  <UP_LETTER> (<CHAR>)*>
|  <UNNAMEDVAR:  "_" (["0"-"9"])* >
|  <CHAR      : (<LETTER> | <DIGIT> | "_")>
|  <LETTER    : ( <LC_LETTER> | <UP_LETTER> )>
|  <LC_LETTER : ["a"-"z"]>
|  <UP_LETTER : ["A"-"Z"]>
|  <DIGIT     : ["0"-"9"]>
}

/* AgentSpeak Grammar */

void agent(Agent a) : { List bbl = new LinkedList(); PlanLibrary pp;  }
{
  belief_base(bbl)
  initial_goals(a)
  pp = plan_base(bbl)
  <EOF>
              { if (a != null) {
                  try {
                    a.getPL().addAll(pp); 
  
                    // add beliefs (when the plans are loaded, so the events are relevant
                    Iterator i = bbl.iterator();
                    while (i.hasNext()) {
 	                   a.addBel((Literal)i.next());
                    }
                  } catch (JasonException je) {
                     System.err.println("Error:"+je);
                  }
                }
              }
}


/* Beliefs & Rules */
void belief_base(List bbl) : { Literal h; LogicalFormula t; }
{
  ( h=literal()
    [
      ":-" t = log_expr()    { h = new Rule(h,t); }
    ] 
    "."                      { bbl.add(h);  } 
  )*
}


/* Initial goals */
void initial_goals(Agent a) : { Literal g; }
{
  ( "!" g=literal() "."   
                    {  if (a != null && a.getTS() != null) {
				          a.getTS().getC().addAchvGoal(g,Intention.EmptyInt);
                       }
                    } 
  )*
}

/* Plans */
PlanLibrary plan_base(List bbl) : { PlanLibrary pp = new PlanLibrary(); 
                                    Plan pl;
                                    Pred dir;
                                    Pred lastBegin = null;
                                    List plansForDirective = null;
                                  }
{
  ( pl = plan()    { try {
                       if (lastBegin == null) {
                          pp.add(pl); 
                       } else {
                          plansForDirective.add(pl);
                       }
                     } catch (JasonException je) {
                       System.err.println("Error adding plan:"+je);
                     }
                   }
                   
    | dir = directive(bbl, pp)
                   { if (dir != null) {
                       // it is a begin or end
                       if (dir.getFunctor().equals("end")) {
                          DirectiveProcessor.process(lastBegin, plansForDirective, bbl, pp); 
                          lastBegin = null;
                       } else {
                          lastBegin = dir;
                          plansForDirective = new ArrayList();
                       }
                     }      
                   }
                   
  )*
                   { if (lastBegin != null) {
                        throw new ParseException("The directive '"+lastBegin+"' does not finish with an 'end'.");
                     }
                     return pp; 
                   }
}

/* Directive */
Pred directive(List bbl, PlanLibrary pl) : 
                   { 
                             Pred d1 = null, d2 = null;
                             boolean isBegin = false; 
                             boolean isEnd = false;
                   }
{
  "{"
   d1 = atom()     { isBegin = d1.getFunctor().equals("begin");
                     isEnd = d1.getFunctor().equals("end");
                   }
   [ d2 = atom() 
                   { if (!isBegin) {
                        throw new ParseException("Directive: a second atom must follow 'begin'.");
                     }
                   }
   ]
  "}"
                   { if (isBegin) {
                        return d2;
                     } else if (isEnd) {
                        return d1;
                     } else {
                        // it is not begin/end directive, process it
                        DirectiveProcessor.process(d1, null, bbl, pl); 
                        return null;
                     }
                   }
}


/* Plan */
Plan plan() :         { Token k; Pred L = null; 
                        Trigger T; LogicalFormula C = null; 
                        ArrayList B = new ArrayList(); 
                        int start = -1, end;}
{
    [ k = <TK_LABEL_AT> L=atom()  { start = k.beginLine; }   ]
    T=trigger()         
    [ k = ":"  C=log_expr()      { if (start == -1) start = k.beginLine; } ] 
    [ k = "<-" plan_body(B)      { if (start == -1) start = k.beginLine; } ]  
    k = "."                      { if (start == -1) start = k.beginLine; } 
                   { end = k.beginLine;
                     Plan p = new Plan(L,T,C,B);
                     p.setSourceLines(start,end);
                     return p;}
                   }

/* Trigger */
Trigger trigger() : { 
               		boolean teType;
			    	byte    teGoal = Trigger.TEBel;
				 	Literal F; 
               }
{
  ( "+"        { teType = Trigger.TEAdd; }
  | "-"        { teType = Trigger.TEDel; }
  )
  
  [ ( "!"      { teGoal = Trigger.TEAchvG; }
    | "?"      { teGoal = Trigger.TETestG; }
    )
  ]
  
  ( F=literal()
  | F=var()
  )            { return new Trigger(teType,teGoal,F); }
}

/* Literal */
Literal literal() :  { Pred F; Token k; boolean type = Literal.LPos; }
{
  ( ( [ <TK_NEG>              { type = Literal.LNeg; }
      ]
      F=atom()                { return new Literal(type,F); }
    )
  | k=<TK_TRUE>               { return Literal.LTrue; } 
  | k=<TK_FALSE>              { return Literal.LFalse; } 
  )
}


/* Plan body */
void plan_body(ArrayList bd) : { BodyLiteral F; }
{
  F=body_formula()         { if (! F.getLogicalFormula().equals(Literal.LTrue)) {
                               bd.add(F);
                             } 
                           }
                 
  [ ";" plan_body(bd) ]
}


BodyLiteral body_formula() :  { Literal A; Token k;
                                BodyType formType = BodyType.action;
                                LogicalFormula rel; VarTerm v;
                              }
{
 
 ( LOOKAHEAD(4)
   // goals and belief updates
   (  "!"             { formType = BodyType.achieve; }
    | "!!"            { formType = BodyType.achieveNF; }
    | "?"             { formType = BodyType.test; }
    | "+"             { formType = BodyType.addBel; }
    | ( "-"           { formType = BodyType.delBel; }
        ["+"          { formType = BodyType.delAddBel; }
        ]
      ) 
   )
   ( A = literal()    { return new BodyLiteral(formType,A); }
   | v = var()        { return new BodyLiteral(formType,v); } // used in communication "+C"
   )
 |
  // actions or expressions
  rel = rel_expr()
                      { if (rel instanceof Literal) {
                          return new BodyLiteral(formType, (Literal)rel);
                        } else {
                          return new BodyLiteral((RelExpr)rel); 
                        }
                      }
 )
}


/* Annotated Atomic Formulae */
Pred atom() :       { Token K; Pred p = new Pred(); Term t; List l; ListTerm lt;}
{
  K=<ATOM>          { p.setFunctor(K.image); } 
  [
      "(" l = terms() 
      ")"           { p.addTerms(l); }
  ]
  [ 
      lt = list()   { p.setAnnots(lt); }
  ] 
  { return p; }
}


/* List of terms */
List terms() : { List listTerms = new ArrayList(); Term v; }
{
  v=term()             { listTerms.add(v); } 
  ( "," v=term()       { listTerms.add(v); }
  )* 
                       { return listTerms; }
}


Term term() :       { Term u; Object o; }
{
  ( u=literal()     
  | u=list()        
  | o=arithm_expr() { return (NumberTerm)o; }
  | u=string()      
  )
  { return u; }
}


ListTermImpl list() : { ListTermImpl lt = new ListTermImpl(); ListTerm last; 
                        Token K; Term f; }
{
  "["
  [
  f=term()                { last = lt.append(f); }
  ( "," f=term()          { last = last.append(f); }
  )*
  [ "|"  ( K=<VAR>        { last.setNext(new VarTerm(K.image)); }
         | K=<UNNAMEDVAR> { last.setNext(new UnnamedVar()); }
         | f=list()       { last = last.concat((ListTerm)f);	   }
         )           
  ]
  ]
  "]"                     { return lt; } 
}


/* logical expression */

LogicalFormula log_expr() :       
                         { LogicalFormula t1, t2; }
{					
   t1 = log_expr_trm()         
[  "|" t2 = log_expr()   { return new LogExpr(t1,LogicalOp.or,t2); } ]
                         { return t1; }
}

LogicalFormula log_expr_trm() : 
                           { LogicalFormula t1, t2; }
{
   t1 = log_expr_factor()    
[  "&" t2 = log_expr_trm() { return new LogExpr(t1,LogicalOp.and,t2); } ]
                           { return t1; }
}

LogicalFormula log_expr_factor():             
                                    { LogicalFormula t; }
{
(  
  <TK_NOT> t = log_expr_factor()    { return new LogExpr(LogicalOp.not,t); } 
 | 
  t = rel_expr()                    { return t; } 
)
}


/* relational expression 
   used in context, body and term
   
     <VAR>      [ <OPREL> <EXP> ]  --> this method returns the VarTerm
   | <LITERAL>  [ <OPREL> <EXP> ]  --> returns the Literal
   | <EXP>      [ <OPREL> <EXP> ]  --> returns the ExprTerm 
*/
LogicalFormula rel_expr() :               {  Object op1 = null;
                                             Object op2 = null;
                                             RelationalOp operator = RelationalOp.none;
                                           }
{
    (   op1 = arithm_expr()                
      | op1 = literal()
      | op1 = string()
    )
                     
    [
       ( "<"                               { operator = RelationalOp.lt; } 
       | "<="                              { operator = RelationalOp.lte; } 
       | ">"                               { operator = RelationalOp.gt; } 
       | ">="                              { operator = RelationalOp.gte; } 
       | "=="                              { operator = RelationalOp.eq; } 
       | "\\=="                            { operator = RelationalOp.dif; } 
       | "="                               { operator = RelationalOp.unify; } 
       | "=.."                             { operator = RelationalOp.literalBuilder; } 
       )

       (   op2 = arithm_expr()        
         | op2 = literal()
         | op2 = string()               
         | op2 = list()
       )

                                           { return new RelExpr((Term)op1, operator, (Term)op2); }
    ]
                                           { return (LogicalFormula)op1; }
}


/* arithmetic expression */
Object arithm_expr() :        { Object t1, t2; ArithmeticOp op;}
{
   t1 = arithm_expr_trm()     { op = ArithmeticOp.none; }
[  ( "+"                      { op = ArithmeticOp.plus;} 
   | "-"                      { op = ArithmeticOp.minus;}
   )
   t2 = arithm_expr()         { if (!(t1 instanceof NumberTerm)) {
                                   throw new ParseException("ArithExpr: first operand is not numeric or variable.");
                                }
                                if (!(t2 instanceof NumberTerm)) {
                                   throw new ParseException("ArithExpr: second operand is not numeric or variable.");
                                }
                                return new ArithExpr((NumberTerm)t1, op, (NumberTerm)t2); 
                              }
]                             { return t1; }
}

Object arithm_expr_trm() :      { Object t1, t2; ArithmeticOp op;}
{
   t1 = arithm_expr_factor()    { op = ArithmeticOp.none; }
[  ( "*"                        { op = ArithmeticOp.times; } 
   | "/"                        { op = ArithmeticOp.div; }
   | <TK_INTDIV>                { op = ArithmeticOp.intdiv; }
   | <TK_INTMOD>                { op = ArithmeticOp.mod; }
   )
   t2 = arithm_expr_trm()       { if (!(t1 instanceof NumberTerm)) {
                                    throw new ParseException("ArithTerm: first operand is not numeric or variable.");
                                  }
                                  if (!(t2 instanceof NumberTerm)) {
                                    throw new ParseException("ArithTerm: second operand is not numeric or variable.");
                                  }
                                  return new ArithExpr((NumberTerm)t1, op, (NumberTerm)t2); 
                                }
]                               { return t1; }
}

Object arithm_expr_factor():   
                                { Object t1, t2; ArithmeticOp op;}
{
   t1 = arithm_expr_simple()    { op = ArithmeticOp.none; }
[  ( "**"                       { op = ArithmeticOp.pow; }
   )
   t2 = arithm_expr_factor()    { if (!(t1 instanceof NumberTerm)) {
                                    throw new ParseException("ArithFactor: first operand is not numeric or variable.");
                                  }
                                  if (!(t2 instanceof NumberTerm)) {
                                    throw new ParseException("ArithFactor: second operand is not numeric or variable.");
                                  }
                                  return new ArithExpr((NumberTerm)t1, op, (NumberTerm)t2); 
                                }
]                               { return t1; }
}


Object arithm_expr_simple():    
                                { Token K; Object t; LogicalFormula f; VarTerm v; }
{
 ( K = <NUMBER>                 { return new NumberTermImpl(K.image); }
 | "-" t = arithm_expr_simple() { if (!(t instanceof NumberTerm)) {
                                    throw new ParseException("operator '-' applied to argument not numeric or variable.");
                                  }
                                  return new ArithExpr(ArithmeticOp.minus, (NumberTerm)t); 
                                }
 | "(" f = log_expr() ")"       { return f; }
 | v = var()                    { return v; }
 )
}


VarTerm var():      { Token K; VarTerm v; ListTerm lt; }
{
 ( K = <VAR>        { v = new VarTerm(K.image); }
 | K = <UNNAMEDVAR> { v = new UnnamedVar(); }
 )
 [ 
   lt = list()      { v.setAnnots(lt); }
 ]
                    { return v; }
}

StringTerm string():{ Token k; }
{
  k = <STRING>      { return new StringTermImpl(k.image.substring(1,k.image.length()-1)); } 
}
