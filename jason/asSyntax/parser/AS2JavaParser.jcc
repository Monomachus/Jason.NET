// Copyright (C) 2003  Rafael H. Bordini, Jomi F. Hubner, et al.
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// 
// To contact the authors:
// http://www.dur.ac.uk/r.bordini
// http://www.inf.furb.br/~jomi
//
//----------------------------------------------------------------------------


options {
   FORCE_LA_CHECK=true;
   STATIC=false;
}

PARSER_BEGIN(as2j)

  package jason.asSyntax.parser;

  import java.util.*;
  import java.io.*;
  import jason.asSyntax.*;
  import jason.asSemantics.*;
  import jason.bb.*;
  import jason.*;
  import jason.asSyntax.ArithExprTerm.ArithmeticOp;
  import jason.asSyntax.LogExprTerm.LogicalOp;
  import jason.asSyntax.RelExprTerm.RelationalOp;
  import jason.asSyntax.BodyLiteral.BodyType;

  public class as2j {

    private String name;
    private File source = null;

    private PrintStream out = System.out;

    /* Auxiliary Functions */

    void setName(String n) {
    	name = n;
    }

    void setSource(File f) {
        source = f;
    }
  }

PARSER_END(as2j)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN : {
// Predefined
  <TK_TRUE: "true">
| <TK_FALSE: "false">
| <TK_NOT:  "not">
| <TK_NEG:  "~">
| <TK_INTDIV: "div">
| <TK_INTMOD: "mod">

// special chars
| <TK_LABEL_AT: "@">

// Numbers
|   <NUMBER: ["0"-"9"] (["0"-"9"])*
          | (["0"-"9"])* "." (["0"-"9"])+ (<EXPONENT>)?
          | (["0"-"9"])+ <EXPONENT> >
|  <EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>

// Strings
|  <STRING: "\"" ( ~["\"","\\","\n","\r"]
                 | "\\" ( ["n","t","b","r","f","\\","\'","\""]
                        | ["0"-"7"] (["0"-"7"])?
                        | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">

// Identifiers
|  <ATOM      : (<LC_LETTER> | "." <CHAR>) (<CHAR> | "." <CHAR>)*>
|  <VAR       :  <UP_LETTER> (<CHAR>)*>
|  <UNNAMEDVAR:  "_">
|  <CHAR      : (<LETTER> | <DIGIT> | "_")>
|  <LETTER    : ( <LC_LETTER> | <UP_LETTER> )>
|  <LC_LETTER : ["a"-"z"]>
|  <UP_LETTER : ["A"-"Z"]>
|  <DIGIT     : ["0"-"9"]>
}

/* AgentSpeak Grammar */

void ag(Agent a) : { List bbl = new LinkedList(); PlanLibrary pp;  }
{
  bs(bbl)
  ig(a)
  pp = ps(bbl)
  <EOF>
              { if (a != null) {
                  try {
                    a.getPS().addAll(pp); 
  
                    // add beliefs (when the plans are loaded, so the events are relevant
                    Iterator i = bbl.iterator();
                    while (i.hasNext()) {
 	                   a.addBel((Literal)i.next());
                    }
                  } catch (JasonException je) {
                     System.err.println("Error:"+je);
                  }
                }
              }
}


/* Beliefs */
void bs(List bbl) : { Literal F; }
{
  ( F=l() "."       {  if(!F.isGround()) {
				            throw new ParseException("Error: Initial belief must be ground!\n       Cannot use "+F+" as initial belief.");
                       }
                       bbl.add(F);
                    } 
  )*
}


/* Initial goals */
void ig(Agent a) : { Literal g; }
{
  ( "!" g=l() "."   {  if (a != null && a.getTS() != null) {
				        a.getTS().getC().addAchvGoal(g,Intention.EmptyInt);
                       }
                    } 
  )*
}

/* Plans */
PlanLibrary ps(List bbl) : { PlanLibrary pp = new PlanLibrary(); Plan pl;  }
{
  ( pl = p()       { try {
                       pp.add(pl); 
                     } catch (JasonException je) {
                       System.err.println("Error adding plan:"+je);
                     }
                   } 
    | directive(bbl,pp)
  )*
                   { return pp; }
}

/* Directive */
void directive(List bbl, PlanLibrary pp) : { Pred d; }
{
  "{"
   d = at()        { Directives.process(d, bbl, pp); }
  "}"
}


/* Plan */
Plan p() :         { Token k; Trigger T; Term C = null; ArrayList H = null; Pred L = null; int start = -1, end;}
{
    [ k = <TK_LABEL_AT> L=at()  { start = k.beginLine; }   ]
    T=te()         
    [ k = ":"  C=le()           { if (start == -1) start = k.beginLine; } ] 
    [ k = "<-" H=bd()           { if (start == -1) start = k.beginLine; } ]  
    k = "."                     { if (start == -1) start = k.beginLine; } 
                   { end = k.beginLine;
                     Plan p = new Plan(L,T,C,H);
                     p.setSourceLines(start,end);
                     return p;}
}

/* Trigger */
Trigger te() : { 
               		boolean teType;
			    	byte    teGoal = Trigger.TEBel;
				 	Literal F; 
               }
{
  ( "+"        { teType = Trigger.TEAdd; }
  | "-"        { teType = Trigger.TEDel; }
  )
  
  [ ( "!"      { teGoal = Trigger.TEAchvG; }
    | "?"      { teGoal = Trigger.TETestG; }
    )
  ]
  
  ( F=l()
  | F=var()
  )            { return new Trigger(teType,teGoal,F); }
}

/* Literal */
Literal l() :  { Pred F; Token k; boolean type = Literal.LPos; }
{
  ( ( [ <TK_NEG>              { type = Literal.LNeg; }
      ]
      F=at()                  { return new Literal(type,F); }
    )
  | k=<TK_TRUE>               { return Literal.LTrue; } 
  | k=<TK_FALSE>              { return Literal.LFalse; } 
  )
}


/* Plan body */
ArrayList bd() : { BodyLiteral F; 
                   ArrayList BD = new ArrayList(); 
                   List BD2;}
{
  F=f()          { if (! F.getTerm().equals(Literal.LTrue)) {
                      BD.add(F); 
                   } 
                 }
                 
  [ ";" BD2=bd() { BD.addAll(BD2); } ]
                 { return BD; }
}


BodyLiteral f() :     { Literal A; Token k;
                        BodyType formType = BodyType.action;
                        Term rel;
                        VarTerm v;
                      }
{
 
 ( LOOKAHEAD(4)
   // goals and belief updates
   (  "!"             { formType = BodyType.achieve; }
    | "!!"            { formType = BodyType.achieveNF; }
    | "?"             { formType = BodyType.test; }
    | "+"             { formType = BodyType.addBel; }
    | ( "-"           { formType = BodyType.delBel; }
        ["+"          { formType = BodyType.delAddBel; }
        ]
      ) 
   )
   ( A=l()            { return new BodyLiteral(formType,A); }
   | v = var()        { return new BodyLiteral(formType,v); } // used in communication "+C"
   )
 |
  // actions or expressions
  rel = re() 
                      { if (rel.isVar() || rel.isLiteral()) {
                          return new BodyLiteral(formType, rel);
                        } else {
                          return new BodyLiteral((RelExprTerm)rel); 
                        }
                      }
 )
}


/* Annotated Atomic Formulae */
Pred at() :         { Token K; Pred p = new Pred(); Term t; List l; ListTerm lt;}
{
  K=<ATOM>          { p.setFunctor(K.image); } 
  [
      "(" l = lt() 
      ")"           { p.addTerms(l); }
  ]
  [ 
      lt = list()   { p.setAnnots(lt); }
  ] 
  { return p; }
}


/* List of terms */
List lt() :         { List listTerms = new ArrayList(); Term v; }
{
  v=t()             { listTerms.add(v); } 
  ( "," v=t()       { listTerms.add(v); }
  )* 
                    { return listTerms; }
}


Term t() :         { Token K; Term u; }
{
  ( u=l()          { return u; }
  | u=list()       { return u; } 
  | u=ae()         { return u; }
  | K=<STRING>     { return new StringTermImpl(K.image.replaceAll("\"", "\\\"")); } 
  )
}


ListTermImpl list() : { ListTermImpl lt = new ListTermImpl(); ListTerm last; 
                        Token K; Term f; }
{
  "["
  [
  f=t()                   { last = lt.append(f); }
  ( "," f=t()             { last = last.append(f); }
  )*
  [ "|"  ( K=<VAR>        { last.setNext(new VarTerm(K.image)); }
         | K=<UNNAMEDVAR> { last.setNext(new UnnamedVar()); }
         | f=list()       { last = last.concat((ListTerm)f);	   }
         )           
  ]
  ]
  "]"                     { return lt; } 
}


/* logical expression */

Term le() :    { Term t1, t2; }
{					
   t1 = le_trm()         
[  "|" t2 = le()         { return new LogExprTerm(t1,LogicalOp.or,t2); } ]
                         { return t1; }
}

Term le_trm() :  { Term t1, t2; }
{
   t1 = le_factor()    
[  "&" t2 = le_trm() { return new LogExprTerm(t1,LogicalOp.and,t2); } ]
                     { return t1; }
}

Term le_factor():             { Term t; }
{
(  
  <TK_NOT> t = le_factor()    { return new LogExprTerm(LogicalOp.not,t); } 
 | 
  t = re()                    { return t; } 
)
}


/* relational expression 
   used in context, body and term
   
     <VAR>      [ <OPREL> <EXP> ]  --> this method returns the VarTerm
   | <LITERAL>  [ <OPREL> <EXP> ]  --> returns the Literal
   | <EXP>      [ <OPREL> <EXP> ]  --> returns the NumberTerm 
*/
Term re() :                               {  Token k;
                                             Term op1 = null;
                                             Term op2 = null;
                                             Term nb; 
                                             RelationalOp operator = RelationalOp.none;
                                             //Term rel = null;
                                           }
{
    (   nb = ae()                          { op1 = nb; }
      | op1 = l()
      | k = <STRING>                       { op1 = new StringTermImpl(k.image); }
    )
                     
    [
       ( "<"                               { operator = RelationalOp.lt; } 
       | "<="                              { operator = RelationalOp.lte; } 
       | ">"                               { operator = RelationalOp.gt; } 
       | ">="                              { operator = RelationalOp.gte; } 
       | "=="                              { operator = RelationalOp.eq; } 
       | "\\=="                            { operator = RelationalOp.dif; } 
       | "="                               { operator = RelationalOp.unify; } 
       | "=.."                             { operator = RelationalOp.literalBuilder; } 
       )

       (   nb = ae()                       { op2 = nb; }
         | op2 = l()
         | k = <STRING>                    { op2 = new StringTermImpl(k.image); }
         | op2 = list()
       )

                                           { return new RelExprTerm(op1, operator, op2); }
    ]
                                           { //if (rel == null && !op1.isVar() && !op1.isLiteral() && !op1.isNumeric()) {
                                             //   throw new ParseException("RelExp: second operand expected!");
                                             //}
                                             //if (rel != null) {
                                             //   return rel; 
                                             //} else { // op1 is a Var or Literal
                                                return op1;
                                             //}
                                           }
}


/* arithmetic expression */
Term ae() :          { Term t1, t2; ArithmeticOp op;}
{
   t1 = trm()        { op = ArithmeticOp.none; }
[  ( "+"             { op = ArithmeticOp.plus;} 
   | "-"             { op = ArithmeticOp.minus;}
   )
   t2 = ae()         { if (!t1.isNumeric()) {
                          throw new ParseException("ArithExpr: first operand is not numeric.");
                      }
                      if (!t2.isNumeric()) {
                          throw new ParseException("ArithExpr: second operand is not numeric.");
                      }
                      return new ArithExprTerm((NumberTerm)t1, op, (NumberTerm)t2); 
                     }
]                    { return t1; }
}

Term trm() :        { Term t1, t2; ArithmeticOp op;}
{
   t1 = factor()    { op = ArithmeticOp.none; }
[  ( "*"            { op = ArithmeticOp.times; } 
   | "/"            { op = ArithmeticOp.div; }
   | <TK_INTDIV>    { op = ArithmeticOp.intdiv; }
   | <TK_INTMOD>    { op = ArithmeticOp.mod; }
   )
   t2 = trm()       { if (!t1.isNumeric()) {
                          throw new ParseException("ArithTerm: first operand is not numeric.");
                      }
                      if (!t2.isNumeric()) {
                          throw new ParseException("ArithTerm: second operand is not numeric.");
                      }
                      return new ArithExprTerm((NumberTerm)t1, op, (NumberTerm)t2); 
                    }
]                   { return t1; }
}

Term factor():      { Term t1, t2; ArithmeticOp op;}
{
   t1 = simple()    { op = ArithmeticOp.none; }
[  ( "**"           { op = ArithmeticOp.pow; }
   )
   t2 = factor()    { if (!t1.isNumeric()) {
                          throw new ParseException("ArithFactor: first operand is not numeric.");
                      }
                      if (!t2.isNumeric()) {
                          throw new ParseException("ArithFactor: second operand is not numeric.");
                      }
                      return new ArithExprTerm((NumberTerm)t1, op, (NumberTerm)t2); 
                    }
]                   { return t1; }
}


Term simple():      { Token K; Term t; VarTerm v; }
{
 ( K = <NUMBER>     { return new NumberTermImpl(K.image); }
 | "-" t = simple() { if (!t.isNumeric()) {
                          throw new ParseException("operator '-' applied to argument not numeric.");
                      }
                      return new ArithExprTerm(ArithmeticOp.minus, (NumberTerm)t); 
                    }
 | "(" t = le() ")" { return t; }
 | v = var()        { return v; }
 )
}

VarTerm var():      { Token K; VarTerm v; ListTerm lt; }
{
 ( K = <VAR>        { v = new VarTerm(K.image); }
 | K = <UNNAMEDVAR> { v = new UnnamedVar(); }
 )
 [ 
   lt = list()      { v.setAnnots(lt); }
 ]
                    { return v; }
}

